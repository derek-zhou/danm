defmodule Danm.HtmlPrinting do
  @moduledoc """
  Generate HTML documents
  """

  alias Danm.Entity
  alias Danm.Sink
  alias Danm.WireExpr
  alias Danm.ComboLogic
  alias Danm.BundleLogic
  alias Danm.ChoiceLogic
  alias Danm.ConditionLogic
  alias Danm.CaseLogic
  alias Danm.Schematic
  alias Danm.BlackBox

  @doc ~S"""
  generate a hier index to the set of html files
  """
  def generate_html_hier(s, in: dir) do
    f = File.open!("#{dir}/hierarchy.html", [:write, :utf8])
    IO.write(f, ~s"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8">
    <title>Module Hierachy</title>
    </head>
    <body>
    <p><a href="hierarchy.html">Hierarchy</a> | <a href="top.html">Top</a></p>
    <h1>Module Hierarchy</h1>
    <div id="tree">
    """)
    print_html_hier(s, f, as: "top")
    IO.write(f, ~s"""
    </div>
    <hr/><p>This document is generated by DANM on #{DateTime.utc_now()}</p>
    </body>
    </html>
    """)
    File.close(f)
    s
  end

  @doc ~S"""
  print html fragment that contains hier index to f
  """
  def print_html_hier(s, f, as: hier) do
    case s.__struct__ do
      Schematic ->
	subs = printable_sub_modules(s)
	if !Enum.empty?(subs) do
	  IO.write(f, "<ul>\n")
	  Enum.each(subs, fn i_name ->
	    inst = s.insts[i_name]
	    IO.write(f, ~s"""
	    <li><a href="#{hier}/#{i_name}.html">#{i_name}</a>
	    (#{Entity.type_string(inst)})</li>
	    """)
	    print_html_hier(inst, f, as: hier <> "/" <> i_name)
	  end)
	  IO.write(f, "</ul>\n")
	end
      _ -> nil
    end
  end

  @doc ~S"""
  generate html for myself and everything below
  """
  def generate_html(s, as: hier, in: dir) do
    case s.__struct__ do
      Schematic ->
	subs = printable_sub_modules(s)
	if !Enum.empty?(subs) do
	  File.mkdir("#{dir}/#{hier}")
	  Enum.each(subs, fn i_name ->
	    inst = s.insts[i_name]
	    generate_html(inst, as: "#{hier}/#{i_name}", in: dir)
	  end)
	end
      _ -> nil
    end
    generate_own_html(s, as: hier, in: dir)
  end

  @doc ~S"""
  generate html for myself only
  """
  def generate_own_html(s, as: hier, in: dir) do
    f = File.open!("#{dir}/#{hier}.html", [:write, :utf8])
    print_html_header(s, f, as: hier)
    print_html_ports(s, f)
    case s.__struct__ do
      Schematic ->
	subs = Schematic.sort_sub_modules(s)
	if !Enum.empty?(subs) do
	  print_html_instance_summary(s, f, subs, as: hier)
	  map = Schematic.pin_to_wire_map(s)
	  IO.write(f, "<ul>\n")
	  Enum.each(subs, fn i_name ->
	    inst = s.insts[i_name]
	    case inst.__struct__ do
	      ChoiceLogic -> print_html_choice_logic(inst, f, as: i_name)
	      ConditionLogic -> print_html_condition_logic(inst, f, as: i_name)
	      CaseLogic -> print_html_case_logic(inst, f, as: i_name)
	      Sink -> print_html_sink(inst, f, as: i_name)
	      t when t in [ComboLogic, BundleLogic] ->
		print_html_simple_logic(inst, f, as: i_name)
	      _ -> print_html_instance(inst, f, as: "#{hier}/#{i_name}", lookup: map)
	    end
	  end)
	  IO.write(f, "</ul><hr/>\n")
	end
      _ -> nil
    end
    print_html_wires(s, f, as: hier)
    print_html_footer(f)
    File.close(f)
    s
  end

  defp get_self_and_up_module(hier) do
    hier
    |> Path.split()
    |> Enum.reverse()
    |> case do
	 [h0, h1 | _ ] -> {h0, h1}
	 [h0 | _ ] -> {h0, nil}
       end
  end

  defp inlined?(s) do
    case s.__struct__ do
      BlackBox -> false
      Schematic -> false
      _ -> true
    end
  end

  defp printable_sub_modules(s) do
    s
    |> Schematic.sort_sub_modules()
    |> Enum.reject(fn n -> inlined?(s.insts[n]) end)
  end

  defp get_top_path(hier) do
    hier |> Path.split() |> tl() |> Enum.map(fn _ -> "../" end) |> Enum.join()
  end

  defp print_html_header(s, f, as: hier) do
    title = "#{hier} (#{Entity.type_string(s)}) Documentation"
    {self_module, up_module} = get_self_and_up_module(hier)
    top_path = get_top_path(hier)
    IO.write(f, ~s"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8">
    <title>#{title}</title>
    <style>
    table { border: 1px solid black; border-collapse: collapse; }
    th, td { border: 1px solid black; padding: 0.25em 1em; text-align: left; }
    tr:nth-child(even) {background-color: #f2f2f2;}
    </style>
    </head>
    <body>
    <p><a href="#{top_path}hierarchy.html">Hierarchy</a>
    """)
    if up_module do
      IO.write(f, ~s"""
      | <a href="../#{up_module}.html#INST_#{self_module}">Up (#{up_module})</a>
      """)
    end
    IO.write(f, ~s"""
    | <a href="#{top_path}top.html">Top</a>
    <h1>#{title}</h1>
    <p>#{Entity.doc_string(s)}</p>
    <p>Defined in: #{s.src}</p><hr/>
    """)
    s
  end

  defp print_html_ports(s, f) do
    IO.write(f, ~s"""
    <h2>Port Summary</h2><table>
    <tr><th>port</th><th>direction</th><th>width</th></tr>
    """)
    s
    |> BlackBox.sort_ports()
    |> Enum.each(fn p_name ->
      {dir, width} = Entity.port_at(s, p_name)
      IO.write(f, ~s"""
      <tr><td><a href="#WIRE_#{p_name}">#{p_name}</a></td><td>#{dir}</td><td>#{width}</td></tr>
      """)
    end)
    IO.write(f, "</table><hr/>\n")
    s
  end

  defp print_html_instance_summary(s, f, subs, as: hier) do
    {self_module, _} = get_self_and_up_module(hier)
    count = Enum.count(subs)
    IO.write(f, "<h2>#{count} Instances</h2><table><tr><th>instance</th><th>module</th></tr>\n")
    Enum.each(subs, fn i_name ->
      inst = s.insts[i_name]
      case inst.__struct__ do
	t when t in [BlackBox, Schematic] ->
	  IO.write(f, ~s"""
	  <tr><td><a href="#INST_#{i_name}">#{i_name}</a></td>
	  <td><a href="#{self_module}/#{i_name}.html">#{inst.name}</a></td></tr>
	  """)
	_ ->
	  IO.write(f, ~s"""
	  <tr><td><a href="#INST_#{i_name}">#{i_name}</a></td>
	  <td>#{Entity.type_string(inst)}</td></tr>
	  """)
      end
    end)
    IO.write(f, "</table>\n")
    s
  end

  defp print_html_instance(s, f, as: hier, lookup: map) do
    {self_module, up_module} = get_self_and_up_module(hier)
    IO.write(f, ~s"""
    <li><h3>Instance <a id="INST_#{self_module}">#{self_module}</a>
    <a href="#{up_module}/#{self_module}.html">(#{s.name})</a></h3>
    <ul><li>Defined in: #{s.src}</li>
    <li>Connections:<table>
    <tr><th>port</th><th>direction</th><th>wire</th></tr>
    """)
    s
    |> BlackBox.sort_ports()
    |> Enum.each(fn p_name ->
      {dir, _} = Entity.port_at(s, p_name)
      w_name = map["#{self_module}/#{p_name}"]
      IO.write(f, ~s"""
      <tr id="PIN_#{self_module}/#{p_name}">
      <td><a href="#{up_module}/#{self_module}.html#WIRE_#{p_name}">#{p_name}</a></td>
      <td>#{dir}</td><td><a href="#WIRE_#{w_name}">#{w_name}</a></td></tr>
    """)
    end)
    IO.write(f, "</table></li></ul></li>\n")
  end

  defp print_html_sink(s, f, as: self) do
    conn_string =
      s
      |> BlackBox.sort_ports()
      |> Enum.map(fn p_name ->
      "<a id=\"PIN_#{self}/#{p_name}\" href=\"#WIRE_#{p_name}\">#{p_name}</a>" end)
      |> Enum.join(", ")

    IO.write(f, ~s"""
    <li><h3>Instance <a id="INST_#{self}">#{self} (#{Entity.type_string(s)})</a></h3>
    <ul><li>Connections: #{conn_string}</li></ul></li>
    """)
  end

  defp print_html_simple_logic(s, f, as: self) do
    pin_fn = fn x -> "<a href=\"#WIRE_#{x}\">#{x}</a>" end
    str = case s.__struct__ do
	    ComboLogic -> WireExpr.ast_string(s.expr, pin_fn)
	    BundleLogic -> BundleLogic.expr_string(s, pin_fn)
	  end
    IO.write(f, ~s"""
    <li><h3>Instance <a id="INST_#{self}" href="#WIRE_#{self}">#{self}</a>
    (#{Entity.type_string(s)})</h3>
    <ul><li>Expression: #{str}</li></ul></li>
    """)
  end

  defp print_html_choice_logic(s, f, as: self) do
    pin_fn = fn x -> "<a href=\"#WIRE_#{x}\">#{x}</a>" end
    cond_str = WireExpr.ast_string(s.condition, pin_fn)
    IO.write(f, ~s"""
    <li><h3>Instance <a id="INST_#{self}" href="#WIRE_#{self}">#{self}</a>
    (#{Entity.type_string(s)})</h3>
    <ul><li>Switch: #{cond_str} <table><tr><th>case</th><th>value</th></tr>
    """)
    Enum.reduce(s.choices, 0, fn c, i ->
      c_str = WireExpr.ast_string(c, pin_fn)
      IO.write(f, "<tr><td>#{i}</td><td>#{c_str}</td></tr>\n")
      i + 1
    end)
    IO.write(f, "</table></li></ul></li>\n")
  end

  defp print_html_condition_logic(s, f, as: self) do
    pin_fn = fn x -> "<a href=\"#WIRE_#{x}\">#{x}</a>" end
    IO.write(f, ~s"""
    <li><h3>Instance <a id="INST_#{self}" href="#WIRE_#{self}">#{self}</a>
    (#{Entity.type_string(s)})</h3>
    <ul><li>Conditions: <table><tr><th>condition</th><th>value</th></tr>
    """)
    s.conditions
    |> Enum.zip(s.choices)
    |> Enum.reduce(0, fn {co, ch}, i ->
      co_str = WireExpr.ast_string(co, pin_fn)
      ch_str = WireExpr.ast_string(ch, pin_fn)
      IO.write(f, "<tr><td>#{co_str}</td><td>#{ch_str}</td></tr>\n")
      i + 1
    end)
    IO.write(f, "</table></li></ul></li>\n")
  end

  defp print_html_case_logic(s, f, as: self) do
    pin_fn = fn x -> "<a href=\"#WIRE_#{x}\">#{x}</a>" end
    sub_str = WireExpr.ast_string(s.subject, pin_fn)
    IO.write(f, ~s"""
    <li><h3>Instance <a id="INST_#{self}" href="#WIRE_#{self}">#{self}</a>
    (#{Entity.type_string(s)})</h3>
    <ul><li>Switch: #{sub_str} <table><tr><th>case</th><th>value</th></tr>
    """)
    s.cases
    |> Enum.zip(s.choices)
    |> Enum.reduce(0, fn {co, ch}, i ->
      co_str = WireExpr.ast_string(co, pin_fn)
      ch_str = WireExpr.ast_string(ch, pin_fn)
      IO.write(f, "<tr><td>#{co_str}</td><td>#{ch_str}</td></tr>\n")
      i + 1
    end)
    IO.write(f, "</table></li></ul></li>\n")
  end

  defp print_html_wires(s, f, as: hier) do
    {self_module, up_module} = get_self_and_up_module(hier)
    count = case s.__struct__ do
	      BlackBox -> Enum.count(Entity.ports(s))
	      Schematic -> Enum.count(s.wires)
	    end
    IO.write(f, "<h2>#{count} wires</h2><ul>\n")
    case s.__struct__ do
      BlackBox ->
	s
	|> BlackBox.sort_ports()
	|> Enum.each(fn p_name ->
	  s
	  |> Entity.port_at(p_name)
	  |> print_html_port(f, as: p_name, self: self_module, up: up_module)
	end)
      Schematic ->
	map = Schematic.wire_width_map(s)
	Enum.each(s.wires, fn {w_name, conns} ->
	  conns
	  |> Enum.reject(fn {i, _} -> i == :self end)
	  |> print_html_wire(s, f,
	    as: w_name,
	    width: map[w_name],
	    port: Entity.port_at(s, w_name),
	    self: self_module,
	    up: up_module)
	end)
    end
    IO.write(f, "</ul><hr/>\n")
  end

  defp print_html_port({dir, width}, f, as: p_name, self: self, up: up) do
    IO.write(f, ~s"""
    <li><h3>Wire <a id="WIRE_#{p_name}">#{p_name}</a></h3><ul>
    <li>width:#{width}</li>
    #{html_port_li(p_name, dir, self, up)}
    </ul></li>
    """)
  end

  defp html_port_li(p_name, dir, self, up) do
    case up do
      nil -> "<li>#{dir} port</li>"
      _ -> "<li><a href=\"../#{up}.html#PIN_#{self}/#{p_name}\">#{dir} port</a></li>"
    end
  end

  defp print_html_wire(conns, s, f, as: w_name, width: width, port: port, self: self, up: up) do
    IO.write(f, ~s"""
    <li><h3>Wire <a id="WIRE_#{w_name}">#{w_name}</a></h3><ul>
    <li>width:#{width}</li>
    """)
    if port do
      {dir, _} = port
      IO.write(f, html_port_li(w_name, dir, self, up))
    end
    unless Enum.empty?(conns) do
      IO.write(f, "<li>connections: <table><tr><th>instance</th><th>port</th></tr>\n")
      Enum.each(conns, fn {ins, port} ->
	if inlined?(s.insts[ins]) do
	  IO.write(f, "<tr><td><a href=\"#INST_#{ins}\">#{ins}</a></td><td></td></tr>")
	else
	  IO.write(f, ~s"""
	  <tr><td><a href="#INST_#{ins}">#{ins}</a></td><td><a href="#PIN_#{ins}/#{port}">#{port}</a></td></tr>
	  """)
	end
      end)
      IO.write(f, "</table></li>\n")
    end
    IO.write(f, "</ul></li>\n")
  end

  defp print_html_footer(f) do
    IO.write(f, ~s"""
    <p>This document is generated by DANM on #{DateTime.utc_now()}</p>
    </body></html>
    """)
  end

end
