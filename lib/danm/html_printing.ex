defmodule Danm.HtmlPrinting do
  @moduledoc """
  Generate HTML documents
  """

  alias Danm.Entity
  alias Danm.BlackBox
  alias Danm.Schematic
  alias Danm.Sink
  alias Danm.WireExpr
  alias Danm.ComboLogic
  alias Danm.BundleLogic
  alias Danm.ChoiceLogic
  alias Danm.ConditionLogic
  alias Danm.CaseLogic
  alias Danm.SeqLogic
  alias Danm.FiniteStateMachine
  alias Danm.Assertion

  # I have my own div/2 for other purpose
  import Kernel, except: [div: 2]
  import Danm.HtmlWriter

  @doc ~S"""
  generate a hier index to the set of html files
  """
  def generate_html_hier(s, in: dir) do
    f = File.open!("#{dir}/hierarchy.html", [:write, :delayed_write, :utf8])

    new_html()
    |> html(fn h ->
      h
      |> head(fn h ->
	h
	|> meta(charset: "utf-8")
	|> title("Module Hierarchy")
      end)
      |> body(fn h ->
	h
	|> p(fn h ->
	  h
	  |> a("Hierarchy", href: "hierarchy.html")
	  |> text(" | ")
	  |> a("Top", href: "top.html")
	end)
	|> h1("Module Hierarchy")
	|> div(fn h ->
	  h
	  |> print_html_hier(s, as: "top")
	end, id: "tree")
	|> hr()
	|> p("This document is generated by DANM on #{DateTime.utc_now()}")
      end)
    end, lang: "en")
    |> export()
    |> invoke(&(IO.write(f, &1)))

    File.close(f)
    s
  end

  @doc ~S"""
  print html fragment that contains hier index to the iodata h
  """
  def print_html_hier(h, s, as: hier) do
    case s.__struct__ do
      Schematic ->
	subs = printable_sub_modules(s)
	cond do
	  Enum.empty?(subs) -> h
	  true ->
	    h
	    |> ul(fn h ->
	      h
	      |> roll_in(subs, fn i_name, h ->
		inst = Map.fetch!(s.insts, i_name)
		h
		|> li(fn h ->
		  h
		  |> a(i_name, href: "#{hier}/#{i_name}.html")
		  |> text("(#{Entity.type_string(inst)})")
		  |> print_html_hier(inst, as: hier <> "/" <> i_name)
		end)
	      end)
	    end)
	end
      _ -> h
    end
  end

  @doc ~S"""
  generate html for myself and everything below
  """
  def generate_html(s, as: hier, in: dir) do
    if s.__struct__ == Schematic do
      subs = printable_sub_modules(s)
      if !Enum.empty?(subs) do
	File.mkdir("#{dir}/#{hier}")
	Enum.each(subs, fn i_name ->
	  inst = Map.fetch!(s.insts, i_name)
	  generate_html(inst, as: "#{hier}/#{i_name}", in: dir)
	end)
      end
    end
    generate_own_html(s, as: hier, in: dir)
  end

  defp generate_own_html(s, as: hier, in: dir) do
    f = File.open!("#{dir}/#{hier}.html", [:write, :delayed_write, :utf8])

    new_html()
    |> html(fn h ->
      title = "#{hier} (#{Entity.type_string(s)}) Documentation"
      h
      |> head(fn h ->
	h
	|> meta(charset: "utf-8")
	|> title(title)
	|> style(~S"""
        table { border: 1px solid black; border-collapse: collapse; }
	th, td { border: 1px solid black; padding: 0.25em 1em; text-align: left; }
	tr:nth-child(even) {background-color: #f2f2f2;}
	""")
      end)
      |> body(fn h ->
	h
	|> p(fn h ->
	  top_path = get_top_path(hier)
	  h
	  |> a("Hierarchy", href: "#{top_path}hierarchy.html")
	  |> invoke(fn h ->
	    {self_module, up_module} = get_self_and_up_module(hier)
	    case up_module do
	      nil ->
		h
		|> text(" | ")
		|> a("Top", href: "#{top_path}top.html")
	      _ ->
		h
		|> text(" | ")
		|> a("Up (#{up_module})", href: "../#{up_module}.html#INST_#{self_module}")
	    end
	  end)
	end)
	|> h1(title)
	|> p(Schematic.doc_string(s))
	|> p("Defined in: #{s.src}")
	|> hr()
	|> print_html_ports(s)
	|> invoke(fn h ->
	  case s.__struct__ do
	    BlackBox -> h
	    Schematic -> print_html_logics(h, s, as: hier)
	  end
	end)
	|> print_html_wires(s, as: hier)
	|> p("This document is generated by DANM on #{DateTime.utc_now()}")
      end)
    end, lang: "en")
    |> export()
    |> invoke(&(IO.write(f, &1)))

    File.close(f)
    s
  end

  defp print_html_logics(h, s, as: hier) do
    subs = Schematic.sort_sub_modules(s)
    cond do
      Enum.empty?(subs) -> h
      true ->
	map = Schematic.pin_to_wire_map(s)
	h
	|> print_html_instance_summary(s, subs, as: hier)
	|> ul(fn h ->
	  Enum.reduce(subs, h, fn i_name, h ->
	    inst = Map.fetch!(s.insts, i_name)
	    case inst.__struct__ do
	      ChoiceLogic -> print_html_choice_logic(h, inst, as: i_name)
	      ConditionLogic -> print_html_condition_logic(h, inst, as: i_name)
	      CaseLogic -> print_html_case_logic(h, inst, as: i_name)
	      SeqLogic -> print_html_seq_logic(h, inst, as: i_name)
	      FiniteStateMachine -> print_html_fsm_logic(h, inst, as: i_name)
	      Assertion -> print_html_assertion(h, inst, as: i_name)
	      Sink -> print_html_sink(h, inst, as: i_name)
	      t when t in [ComboLogic, BundleLogic] ->
		print_html_simple_logic(h, inst, as: i_name)
	      t when t in [BlackBox, Schematic] ->
		print_html_instance(h, inst, as: "#{hier}/#{i_name}", lookup: map)
	    end
	  end)
	end)
	|> hr()
    end
  end

  defp get_self_and_up_module(hier) do
    hier
    |> Path.split()
    |> Enum.reverse()
    |> case do
	 [h0, h1 | _ ] -> {h0, h1}
	 [h0 | _ ] -> {h0, nil}
       end
  end

  defp inlined?(s) do
    case s.__struct__ do
      BlackBox -> false
      Schematic -> false
      _ -> true
    end
  end

  defp printable_sub_modules(s) do
    Schematic.sort_sub_modules(s, except: &inlined?/1)
  end

  defp get_top_path(hier) do
    hier |> Path.split() |> tl() |> Enum.map(fn _ -> "../" end) |> Enum.join()
  end

  defp print_html_ports(h, s) do
    h
    |> h2("Port Summary")
    |> table(fn h ->
      h
      |> tr(fn h -> h |> th("port") |> th("direction") |> th("width") end)
      |> roll_in(BlackBox.sort_ports(s), fn p_name, h ->
	{dir, width} = Map.fetch!(s.ports, p_name)
	h
	|> tr(fn h ->
	  h
	  |> td(&a(&1, p_name, href: "#WIRE_#{p_name}"))
	  |> td(to_string(dir))
	  |> td(to_string(width))
	end)
      end)
    end)
    |> hr()

  end

  defp print_html_instance_summary(h, s, subs, as: hier) do
    {self_module, _} = get_self_and_up_module(hier)
    count = Enum.count(subs)

    h
    |> h2("#{count} Instances")
    |> table(fn h ->
      h
      |> tr(fn h -> h |> th("instance") |> th("module") end)
      |> roll_in(subs, fn i_name, h ->
	inst = Map.fetch!(s.insts, i_name)
	case inst.__struct__ do
	  t when t in [BlackBox, Schematic] ->
	    h
	    |> tr(fn h ->
	      h
	      |> td(&a(&1, i_name, href: "#INST_#{i_name}"))
	      |> td(&a(&1, inst.name, href: "#{self_module}/#{i_name}.html"))
	    end)
	  _ ->
	    h
	    |> tr(fn h ->
	      h
	      |> td(&a(&1, i_name, href: "#INST_#{i_name}"))
	      |> td(Entity.type_string(inst))
	    end)
	end
      end)
    end)

  end

  defp print_html_instance(h, s, as: hier, lookup: map) do
    {self_module, up_module} = get_self_and_up_module(hier)

    h
    |> li(fn h ->
      h
      |> h3(fn h ->
	h
	|> a("Instance #{self_module}", id: "INST_#{self_module}")
	|> a("(#{s.name})", href: "#{up_module}/#{self_module}.html")
      end)
      |> ul(fn h ->
	h
	|> li("Defined in: #{s.src}")
	|> li(fn h ->
	  h
	  |> text("Connections")
	  |> table(fn h ->
	    h
	    |> tr(fn h -> h |> th("port") |> th("direction") |> th("wire") end)
	    |> roll_in(BlackBox.sort_ports(s), fn p_name, h ->
	      {dir, _} = Map.fetch!(s.ports, p_name)
	      w_name = Map.fetch!(map, "#{self_module}/#{p_name}")
	      h
	      |> tr(fn h ->
		h
		|> td(&a(&1, p_name, href: "#{up_module}/#{self_module}.html#WIRE_#{p_name}"))
		|> td(to_string(dir))
		|> td(&a(&1, w_name, href: "#WIRE_#{w_name}"))
	      end, id: "PIN_#{self_module}/#{p_name}")
	    end)
	  end)
	end)
      end)
    end)
  end

  defp print_html_sink(h, s, as: self) do
    print_html_logic(h, s, &print_sink_core/2, as: self)
  end

  defp print_sink_core(h, s) do
    conn_string =
      s.inputs
      |> Map.keys()
      |> Enum.sort(:asc)
      |> Enum.map(&html_wire_string/1)
      |> Enum.join(", ")

    li(h, "Connections: #{conn_string}")
  end

  defp print_html_assertion(h, s, as: self) do
    print_html_logic(h, s, &print_assertion_core/2, as: self)
  end

  defp print_assertion_core(h, s) do
    str = WireExpr.ast_string(s.expr, &html_wire_string/1)
    case s.clk do
      nil -> h |> li("Assertion: #{str}")
      clk ->
	clk_str = html_wire_string(clk)
	h
	|> li("Assertion: #{str}")
	|> li("Clocked by: #{clk_str}")
    end
  end

  defp html_wire_string(x), do: "<a href=\"#WIRE_#{x}\">#{x}</a>"

  defp print_html_simple_logic(h, s, as: self) do
    print_html_logic(h, s, &print_simple_logic_core/2, as: self)
  end

  defp print_html_choice_logic(h, s, as: self) do
    print_html_logic(h, s, &print_choice_logic_core/2, as: self)
  end

  defp print_html_condition_logic(h, s, as: self) do
    print_html_logic(h, s, &print_condition_logic_core/2, as: self)
  end

  defp print_html_case_logic(h, s, as: self) do
    print_html_logic(h, s, &print_case_logic_core/2, as: self)
  end

  defp print_html_seq_logic(h, s, as: self) do
    print_html_logic(h, s, &print_seq_logic_core/2, as: self)
  end

  defp print_html_fsm_logic(h, s, as: self) do
    print_html_logic(h, s, &print_fsm_logic_core/2, as: self)
  end

  defp print_html_logic(h, s, core_fn, as: self) do
    h
    |> li(fn h ->
      h
      |> h3(fn h ->
	h
	|> a("Instance #{self}", id: "INST_#{self}")
	|> text("(#{Entity.type_string(s)})")
      end)
      |> ul(&core_fn.(&1, s))
    end)
  end

  defp print_simple_logic_core(h, s) do
    str = case s.__struct__ do
	    ComboLogic -> WireExpr.ast_string(s.expr, &html_wire_string/1)
	    BundleLogic -> BundleLogic.expr_string(s, &html_wire_string/1)
	  end

    li(h, "Expression: #{str}")
  end

  defp print_choice_logic_core(h, s) do
    cond_str = WireExpr.ast_string(s.condition, &html_wire_string/1)

    h
    |> li(fn h ->
      h
      |> text("Switch: #{cond_str}")
      |> table(fn h ->
	h
	|> tr(fn h -> h |> th("case") |> th("value") end)
	|> roll_in(Enum.with_index(s.choices), fn {c, i}, h ->
	  c_str = WireExpr.ast_string(c, &html_wire_string/1)
	  tr(h, fn h -> h |> td(to_string(i)) |> td(c_str)
	  end)
	end)
      end)
    end)
  end

  defp print_condition_logic_core(h, s) do
    h
    |> li(fn h ->
      h
      |> text("Conditions: ")
      |> table(fn h ->
	h
	|> tr(fn h -> h |> th("condition") |> th("value") end)
	|> roll_in(Enum.zip(s.conditions, s.choices), fn {co, ch}, h ->
	  co_str = WireExpr.ast_string(co, &html_wire_string/1)
	  ch_str = WireExpr.ast_string(ch, &html_wire_string/1)
	  tr(h, fn h -> h |> td(co_str) |> td(ch_str) end)
	end)
      end)
    end)
  end

  defp print_case_logic_core(h, s) do
    sub_str = WireExpr.ast_string(s.subject, &html_wire_string/1)

    h
    |> li(fn h ->
      h
      |> text("Switch: #{sub_str}")
      |> table(fn h ->
	h
	|> tr(fn h -> h |> th("case") |> th("value") end)
	|> roll_in(Enum.zip(s.cases, s.choices), fn {co, ch}, h ->
	  co_str = WireExpr.ast_string(co, &html_wire_string/1)
	  ch_str = WireExpr.ast_string(ch, &html_wire_string/1)
	  tr(h, fn h -> h |> td(co_str) |> td(ch_str) end)
	end)
      end)
    end)
  end

  defp print_seq_logic_core(h, s) do
    clk_str = html_wire_string(s.clk)

    h
    |> li("Clocked by: #{clk_str}")
    |> invoke(fn h ->
      case s.core.__struct__ do
	ChoiceLogic -> print_choice_logic_core(h, s.core)
	ConditionLogic -> print_condition_logic_core(h, s.core)
	CaseLogic -> print_case_logic_core(h, s.core)
	_ -> print_simple_logic_core(h, s.core)
      end
    end)
  end

  defp print_fsm_logic_core(h, s) do
    clk_str = html_wire_string(s.clk)

    h
    |> li("Clocked by: #{clk_str}")
    |> li(fn h ->
      h
      |> text("State transition: ")
      |> table(fn h ->
	h
	|> tr(fn h -> h |> th("state") |> th("condition") |> th("next state") end)
	|> roll_in(s.graph, fn {state, transit}, h ->
	  span = to_string(Enum.count(transit))
	  h
	  |> roll_in(Enum.with_index(transit), fn {{co, ns}, i}, h ->
	    co_str = WireExpr.ast_string(co, &html_wire_string/1)
	    case i do
	      0 ->
		tr(h, fn h ->
		  h
		  |> td(to_string(state), rowspan: span)
		  |> td(co_str)
		  |> td(to_string(ns))
		end)
	      _ -> tr(h, fn h -> h |> td(co_str) |> td(to_string(ns)) end)
	    end
	  end)
	end)
      end)
    end)
  end

  defp print_html_wires(h, s, as: hier) do
    {self_module, up_module} = get_self_and_up_module(hier)
    count = case s.__struct__ do
	      BlackBox -> Enum.count(s.ports)
	      Schematic -> Enum.count(s.wires)
	    end

    h
    |> h2("#{count} wires")
    |> ul(fn h ->
      case s.__struct__ do
	BlackBox ->
	  Enum.reduce(s.ports, h, fn {p_name, port}, h ->
	    print_html_port(h, port, as: p_name, self: self_module, up: up_module)
	  end)
	Schematic ->
	  map = Schematic.wire_width_map(s)
	  Enum.reduce(s.wires, h, fn {w_name, conns}, h ->
	    conns = Enum.reject(conns, fn {i, _} -> i == :self end)
	    print_html_wire(h, conns, s,
	      as: w_name,
	      width: Map.fetch!(map, w_name),
	      port: Map.get(s.ports, w_name),  # could be nil
	      self: self_module,
	      up: up_module)
	  end)
      end
    end)
    |> hr()
  end

  defp print_html_port(h, {dir, width}, as: p_name, self: self, up: up) do
    h
    |> li(fn h ->
      h
      |> h3(&a(&1, "Wire #{p_name}", id: "WIRE_#{p_name}"))
      |> ul(fn h ->
	h
	|> li("width:#{width}")
	|> html_port_li(p_name, dir, self, up)
      end)
    end)
  end

  defp html_port_li(h, p_name, dir, self, up) do
    case up do
      nil -> h |> li("#{dir} port")
      _   -> h |> li(&a(&1, "#{dir} port", href: "../#{up}.html#PIN_#{self}/#{p_name}"))
    end
  end

  defp print_html_wire(h, conns, s, as: w_name, width: width, port: port, self: self, up: up) do
    h
    |> li(fn h ->
      h
      |> h3(&a(&1, "Wire #{w_name}", id: "WIRE_#{w_name}"))
      |> ul(fn h ->
	h
	|> li("width:#{width}")
	|> invoke(fn h ->
	  case port do
	    nil -> h
	    {dir, _} -> html_port_li(h, w_name, dir, self, up)
	  end
	end)
	|> invoke(fn h ->
	  cond do
	    Enum.empty?(conns) -> h
	    true -> print_html_wire_conns(h, conns, s)
	  end
	end)
      end)
    end)
  end

  defp print_html_wire_conns(h, conns, s) do
    h
    |> li(fn h ->
      h
      |> text("connections: ")
      |> table(fn h ->
	h
	|> tr(fn h -> h |> th("instance") |> th("port")	end)
	|> roll_in(conns, fn {ins, port}, h ->
	  h
	  |> tr(fn h ->
	    cond do
	      inlined?(Map.fetch!(s.insts, ins)) ->
		h
		|> td(&a(&1, ins, href: "#INST_#{ins}"))
		|> td("")
	      true ->
		h
		|> td(&a(&1, ins, href: "#INST_#{ins}"))
		|> td(&a(&1, port, href: "#PIN_#{ins}/#{port}"))
	    end
	  end)
	end)
      end)
    end)
  end

end
